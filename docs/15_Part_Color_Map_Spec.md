# SPEC: Карта допустимых цветов для деталей на основе BrickLink (v2, с нуля)

## Цель
Определить **строгий процесс** и **форматы данных**, позволяющие из официальной выгрузки BrickLink
получить карту допустимых комбинаций «деталь ↔ цвет». Документ рассчитан на команду ETL/обработки
и независим от реализации скриптов.

---

## 1. Входные данные (источник = BrickLink `catalogDownload.asp`)

**Обязательный файл**
- **Part & Color Codes** (`viewType=5`) — связь деталь–цвет.

**Рекомендуемые файлы**
- **Colors** (`viewType=3`) — справочник цветов (валидация/обогащение).
- **Items (Parts)** (`viewType=0`, `itemType=P`) — справочник деталей (валидация).

**Технические характеристики**
- Формат: TSV (разделитель `\t`), первая строка — заголовки.
- Кодировка: UTF‑8.
- Пустые значения — пустая строка (нормализуются в `null` там, где уместно).

---

## 2. Обязательные поля и маппинг заголовков

### 2.1 Part & Color Codes (viewType=5) — ОБЯЗАТЕЛЬНО
Ищем (case‑insensitive, trim заголовков; допускаем варианты):

| Назначение | Допустимые заголовки                     | Тип     | Обяз. |
|------------|-------------------------------------------|---------|-------|
| partId     | `Number`, `Item No`, `ItemNo`, `Part No`, `Part Number` | string  | ✅ |
| colorId    | `Color ID`, `ColorID`, `Color Code`       | int     | ✅ |
| hasImg     | `Has Image`, `HasImage`, `Image`, `Img`   | bool\|null | ❌ |

Правила значения:
- `partId`: `trim()`, непустая строка, без смены регистра.
- `colorId`: целое `>= 0`.
- `hasImg`: значения `{"1","true","yes","y"}` → `true`; `{"0","false","no","n"}` → `false`; иначе `null`.

### 2.2 Colors (viewType=3) — РЕКОМЕНДОВАНО
| Назначение | Заголовки          | Тип         | Обяз. | Нормализация                     |
|------------|--------------------|-------------|-------|----------------------------------|
| id         | `Color ID`,`ColorID` | int         | ✅     |                                  |
| name       | `Color Name`       | string      | ✅     | `trim()`                          |
| rgb        | `RGB`              | string\|null| ✅     | `HEX6` UPPERCASE, без `#`; иначе `null` |

### 2.3 Items (viewType=0, itemType=P) — ОПЦИОНАЛЬНО
| Назначение | Заголовки                 | Тип    | Обяз. |
|------------|---------------------------|--------|-------|
| blId       | `Number`,`Item No`,`ItemNo` | string | ✅ |
| name       | `Name`                    | string | ✅ |
| catId      | `Category ID`             | int    | ✅ |

---

## 3. Алгоритм построения карты

### Шаг 1. Чтение таблицы Part & Color Codes
Для каждой строки:
1. Считать `partId` и `colorId`; если один из них отсутствует/некорректен — пропустить.
2. Нормализовать `hasImg` в `true/false/null` по правилам §2.1.

### Шаг 2. Дедупликация
- Ключ связи = пара `(partId, colorId)`.
- Объединение флага: `hasImg_acc = hasImg_acc OR (hasImg == true)`.
- Результат — множество уникальных связей с агрегированным `hasImg_acc ∈ {true,false}` (если не было ни одного явного значения — `null`).

### Шаг 3. Валидация (рекомендуется)
- Если есть `Colors`: удалять связи с `colorId`, отсутствующими в справочнике.
- Если есть `Items(Parts)`: опционально удалять связи с несуществующими `partId` (или логировать предупреждения).

### Шаг 4. Формирование индексов
- **part_to_colors**: `Dict[str, List[Tuple[int, bool|null]]]` — сгруппировать связи по `partId`.  
- **color_to_parts**: `Dict[int, List[str]]` — сгруппировать связи по `colorId`.

### Шаг 5. Сортировка (для стабильности)
- Внутри `part_to_colors[partId]`: упорядочить по `colorId` возр.
- Внутри `color_to_parts[colorId]`: упорядочить лексикографически по `partId`.

---

## 4. Выходные форматы

### 4.1 Табличный (LCX‑Tabular) — предпочтительный
Таблица `partColors`:

```
cols: ["partId","colorId","hasImg"]
rows: [
  ["122c01", 11, true],
  ["122c01",  7, null],
  ["10p01",   0, false]
]
```

Особенности:
- Одна строка = одна уникальная пара `(partId,colorId)`.
- `hasImg` может быть `true`, `false` или `null`.

### 4.2 Карты доступа (для быстрых lookup’ов)

**По деталям:**
```json
{
  "122c01": [[11,true],[7,null],[0,false]],
  "10p01":  [[0,false]]
}
```

**По цветам:**
```json
{
  "11": ["122c01","3023"],
  "0":  ["122c01","10p01"]
}
```

> Для фронтенда рекомендуется хранить `partColors` в IndexedDB/SQLite‑wasm с индексами по `partId` и `colorId`,
> а не держать целиком карты в памяти.

---

## 5. Контроль качества

Минимальный набор метрик после сборки:
- `links_total` — количество уникальных связей `(partId,colorId)`.
- `parts_total` — число уникальных `partId`.
- `colors_total` — число уникальных `colorId`.
- `%unknown_colors` — доля связей с `colorId` вне справочника (если Colors загружен).
- `%unknown_parts` — доля связей с `partId` вне Items (если Items загружен).
- `%hasImg_true` / `%hasImg_null` — доли по флагу изображения.

Тест‑проверки:
- Случайная выборка `N` деталей → проверить разумное количество цветов.
- Проверить, что нет детали, у которой «все цвета» (если такая аномалия невозможна по доменной логике).

---

## 6. Пограничные ситуации и обработка ошибок

- **HTML вместо TSV**: вероятна проблема авторизации — сигнализировать об ошибке, записать фрагмент ответа для диагностики.
- **Непредвиденные заголовки**: логировать первую строку, разрешать конфиг‑override для маппинга.
- **Дубликаты строк**: корректно агрегируются на шаге дедупликации.
- **Большой объём**: обрабатывать построчно/пакетами; не грузить всё в память.

---

## 7. Контракт интеграции

**Вход:** TSV‑файлы BrickLink (Part & Color Codes — обязателен; Colors/Items — опционально).  
**Выход:** одна из форм:
1) LCX‑табличка `partColors` (см. §4.1), или  
2) JSON‑карты `part_to_colors.json` и/или `color_to_parts.json` (см. §4.2).

**Семантика обновления:** idempotent upsert — новая поставка полностью заменяет старую.

---

## 8. Пример (минимальный)

**Вход (TSV Part & Color Codes):**
```
Number	Color ID	Has Image
122c01	11	1
122c01	7	
10p01	0	0
```

**Выход (LCX‑табличный вид):**
```
cols: ["partId","colorId","hasImg"]
rows: [
  ["122c01",11,true],
  ["122c01",7,null],
  ["10p01",0,false]
]
```

---

## 9. Нормативные требования (кратко)
- Таб‑разделитель, UTF‑8, первая строка — заголовки.
- Case‑insensitive сопоставление заголовков.
- Пропуск строк с пустыми ключами.
- Агрегация `hasImg` по правилу «есть хотя бы одно `true`».

